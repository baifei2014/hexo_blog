---
title: 串的模式匹配算法
tags: [算法, 匹配, BF算法, KMP算法, golang]
date: 2021-07-19 18:46:18
---

> 串的模式匹配是指在一个主串s中查找是否存在子串t，如果存在，返回子串第一个字符串在主串中出现的位置。匹配算法在数据结构中常有介绍，应用十分广泛，比如说搜索引擎，语言翻译等等。在业务开发中，也经常用到子字符串查找包含。著名的匹配算法有BF算法和KMP算法，本文主要介绍下自己对串模式匹配算法的理解及实现。

## BF算法

### 描述与实现

BF算法是最简单直观的匹配。它的匹配过程是指，主串从指定pos位置开始计数指针为i，子串从第一个字符开始，计数指针为j，如果s[i]等于t[j]，那么i和j分别移向下一个位置比较，如果不等，那就从新开始比较，i从主串的下一个字符，也就是i=i-j+2再重新和子串的第一个字符比较。如果最后比较到j大于等于子串长度，匹配成功。

代码示例:

```golang
func indexBF(s string, t string, pos int) int {
	i := pos
	j := 0
	for i < len(s) && j < len(t) {
		if s[i] == t[j] {
			i += 1
			j += 1
		} else {
			i = i - j + 1
			j = 0
		}
	}
	if j >= len(t) {
		return i - len(t)
	}
	return 0
}
```

### 算法分析

BF算法简单易于理解，并且效率在大多数情况下都能满足需要，但是如果考虑一些极端情况，我们会发现会有一些地方可以优化。

- 最好的情况：每次不成功的匹配都是发生在第一个字符的匹配，也就是子串第一个字符和主串匹配时就不满足，这种最好的情况的时间复杂度是O(`m+n`)。

- 最坏的情况：每次不成功的匹配都是发生在最后一个字符，也就是子串匹配到最后一个字符时发现不满足，这种情况下时间复杂度是最高的，最坏情况的复杂度是O(`m*n`)。

在BF模式里，每次匹配不成功都会主串和子串都会回溯，这样可能出现不必要的回溯，因为已经部分匹配的结果是可以利用的。这就引出了KMP算法，一种可以在O(`m*n`)的时间复杂度上完成匹配操作的算法。

## KMP算法

### 描述与实现

KMP算法相对于BF算法，变化在于不用回溯主串i指针，而是利用已经部分匹配的结果回溯j指针。

在KMP算法中，需要一个next函数，令next[j] = k，则next[j]表示子串中第j个字符与主串中相应字符不匹配时，在模式中需要重新和主串中该字符进行比较的字符的位置。

匹配过程是这样的：假设指针i和j分别指向主串和子串待比较字符，若s[i]等于t[j]，i和j分别加1，否则i指针不变，j退到next[j]的位置比较，如果相等，继续俩指针各自加1，否则，再退到下一个位置去，直到退到0，这时需要将子串也就是模式串向右滑动一个位置，主串也从下一个位置和子串重新开始匹配。

这就是KMP算法，主要就是依赖一个next函数，减少了很多无意义的回溯。

```golang
// s主串,t模式串
func indexKMP(s string, t string, pos int) int {
	i := pos
	j := 0
	next := getNext(t)
	for i < len(s) && j < len(t) {
		if j == 0 || s[i] == t[j] {
			i += 1
			j += 1
		} else {
			j = next[j]
		}
	}
	if j >= len(t) {
		return i - len(t)
	}
	return 0
}
```

我们看到，KMP算法在一个next数组的基础上进行，那如何获取next数组，也就是next函数如何实现呢，代码如下：

```golang
func getNext(t string) []int {
	i := 1
	j := 0
	next := make([]int, len(t)+1)
	for i < len(t) {
		if j == 0 || t[i] == t[j] {
			i += 1
			j += 1
			if i < len(t) && j < len(t) && t[i] != t[j] {
				next[i] = j
			} else {
				next[i] = next[j]
			}
		} else {
			j = next[j]
		}
	}
	return next
}
```

实际意义就是在子串也就是模式串中寻找子串，这样就能利用部分匹配到的结果了。

## 总结

以上就是串的模式匹配算法的两种实现，当然虽然KMP算法的时间复杂度是O(`m*n`)，但是很多情况下，BF算法的复杂度近似于O(`m+n`)，所以很多场景下一直在使用，只有在主串和子串中存在很多部分匹配时，才比BF算法快的多。





